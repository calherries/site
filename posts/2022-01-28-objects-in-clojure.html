<html><head><meta charset="UTF-8"><title>Cal Herries</title><meta content="My personal site." name="description"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="../resources/public/css/app-components.css" rel="stylesheet"><link href="../resources/public/css/app-utilities.css" rel="stylesheet"><link href="../resources/public/css/github.css" rel="stylesheet"><link href="https://use.typekit.net/kxb8fhj.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Crimson+Pro" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/clojure.min.js"></script><script>hljs.highlightAll()</script></head><body class="p-8"><div class="flex gap-5 mb-4"><h2 class="font-bold"><a href="/">Home</a></h2><h2 class="font-bold"><a href="/posts.html">Posts</a></h2></div><div class="my-3"><h1>Objects in Clojure</h1><p>Objects are functions. Every functional programming language can implement them, even if they're not supported at the language level.</p><p>To demonstrate, let's compare stack objects in Python and Clojure.</p><p>Here's the Python implementation:</p><pre><code class="Python">class Stack:
  def __init__(self):
    self.elements = []

  def push(self, data):
    self.elements = [data] + self.elements

  def pop(self):
    if len(self.elements):
      result = self.elements[0]
      self.elements = self.elements[1:]
      return result
    else:
      return None

stack = Stack()
stack.push(1)
stack.push(2)
print(stack.elements)
</code></pre><p></p><p>And here's how we use it:</p><pre><code>stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
stack.pop()
=&gt; 3
stack.elements 
=&gt; [2, 1]
</code></pre><p>Straight-forward stuff. Now, how about Clojure?</p><pre><code class="Clojure">(defn new-stack []
  (let [elements (atom [])]
    (fn [method]
      (case method
        :push     (fn [x]
                    (swap! elements #(cons x %))
                    nil)
        :pop      (fn []
                    (let [result (first @elements)]
                      (swap! elements rest)
                      result))
        :elements (fn [] @elements)))))
</code></pre><p>It's a bit noisier than the Python version, but it works in a similar way. Here's how you use it:</p><pre><code class="Clojure">(def stack (new-stack))
((stack :push) 1)
((stack :push) 2)
((stack :push) 3)
((stack :pop))
=&gt; 3
((stack :elements))
=&gt; (2 1)
</code></pre><p></p><p>Notice the similarity?</p><p>The Clojure &quot;class&quot; is just a function that returns a function. That returned function is an object! It has it's own internal state, and has a set of methods that operate on that state. You can get a method from the object by calling the function with the method name. Once you've got the method from the object, you can call it like a normal function. The difference between a method and a typical function is that the method has access to the object's internal state.</p><pre><code class="Clojure">object  method-name
   |       |
   |       |
   .       .
((stack :push) 3)
  ...........  .
       |       |
       |       |
       |       |
       |       |
    method   method-argument
</code></pre><p>There's no built-in <code>class</code> symbol in Clojure that can create objects for us. But that doesn't mean it doesn't support OOP! You can think of Python's <code>class</code> symbol as syntactic sugar. Semantically, it creates a function. Of course there's more the <code>class</code> can do, like inheritance. We could implement with functions too, but that's for another post! </p></div></body></html>