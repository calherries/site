<html><head><meta charset="UTF-8"><title>Cal Herries</title><meta content="My personal site." name="description"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="../resources/images/favicon.ico" rel="icon" type="image/x-icon"><link href="../resources/public/css/app-components.css" rel="stylesheet"><link href="../resources/public/css/app-utilities.css" rel="stylesheet"><link href="../resources/public/css/github.css" rel="stylesheet"><link href="https://use.typekit.net/kxb8fhj.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Crimson+Pro" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/clojure.min.js"></script><script>hljs.highlightAll()</script></head><body class="p-8"><div class="flex gap-5 mb-4"><h2 class="font-bold"><a href="/" style="color:#6679CC;border-color:#6679CC;">Home</a></h2></div><div class="my-3"><h1>Abstraction</h1><p>Abstraction is a widely used, but deeply overloaded term. Programming is full of tropes like &quot;program at the right level of abstraction&quot;, and &quot;avoid premature abstraction&quot;.</p><p>Like many, I consider it an indispensable term for reasoning in programming discussions. So it's worth nailing down its definition.</p><p>Let's start with the definition from Rich Hickey: &quot;Abstraction is about drawing from a set of exemplars some essential thing.&quot;</p><p>(Fun side note: this definition is recursive: abstraction is <i>itself</i> an abstraction.)</p><p>If abstraction is understood as drawing from a set of exemplars, let's look at an example: the collection abstraction in Clojure. </p><p>A collection supports three operations:</p><ul><li>count - for getting the size of the collection</li><li>conj - for 'adding' to the collection</li><li>seq - to get a sequence that can walk the entire collection</li></ul><p>The collection abstraction is defined by these operations, combined with these invariants:</p><ul><li>the sequence of items in the collection contains all the items that have been added to the collection</li><li>the size of the collection is equal to number of items that have been added to the collection</li></ul><p>These properties adhere to Rich's definition of an abstraction. If something has an implementation for the above operations, which satisfy these invariants, it is a collection.</p><p>This idea of a collection is an abstract one, precisely because it omits details of how it works. There is not enough information in the definition to create a working collection. There is only enough information to say what a collection <i>is</i>. The abstraction does not specify anything about how its invariants are maintained, or how its operations are implemented. That is the job of the abstraction's concretions. This reveals a fundamental property of abstraction: if an abstraction is about finding common things</p><p>The set of concretions for the collection abstraction include anything that contains more information and still has the properties of the abstraction. The mapping of concretions to the abstract type is called an abstraction mapping, or an abstraction function.</p><h3>Not abstractions</h3><p>It's worth taking a step back and acknowledging some things that are clearly not abstractions by themselves:</p><p><strong>Interfaces and protocols</strong></p><p>An interface or protocol is not sufficient to create an abstraction. Things that describe the operations on a data type are not abstractions, since they omit invariants. The IPersistentCollection is the interface for the collection in Clojure, but it is clearly not the abstraction in itself. </p><p>Interfaces or protocols are not even necessary to create an abstraction. Consider the abstraction of a point in 2D space.</p><pre><code>(def my-map-point {:x 10 :y 20})
(def my-vector-point [10 20])
(def my-string-point &quot;Point(10, 20)&quot;)
</code></pre><p>We could create a protocol that define a set of valid operations on points. That might be good programming practice, but it's unnecessary to imagine the point abstraction. We already know what a point is without writing <i>any</i> code. To prove my point, consider how the above examples clearly map to the same value in the abstract space.</p><p><strong>Functions</strong></p><p>Functions are black boxes that take inputs, might do something, and return a value. They're helpful for making concretions, but they aren't an abstraction in themselves.</p><p><strong>Classes</strong></p><p>Classes combine interfaces (the classes' methods) with implementations of the interface. If an interface isn't required for an abstraction, a class certainly isn't.</p><p><strong>Types</strong></p><p>A type is a set of values, together with the ability to constrain the available operations you can make on each value of the type. An abstraction is not a type, because it doesn't allow you to constrain operations in any way, as a type does. Two examples: the collection abstraction isn't a type, and neither is the point abstraction above. The confusion here is that creating a type often comes with a new abstraction. For example, creating a Point type in Haskell:</p><pre><code>data Point = MakePoint Double Double
</code></pre><h3>Why should we care?</h3><p>As a software engineer, I'm interested in reducing the cost of higher quality software. But to make progress we need to share a common language. I find it hard to talk about abstraction with other programmers because the term is so loose and meaningless. Hopefully this post can help change that.</p></div></body></html>