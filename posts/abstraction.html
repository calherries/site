<html><head><meta charset="UTF-8"><title>Cal Herries</title><meta content="My personal site." name="description"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="../resources/images/favicon.ico" rel="icon" type="image/x-icon"><link href="../resources/public/css/app-components.css" rel="stylesheet"><link href="../resources/public/css/app-utilities.css" rel="stylesheet"><link href="../resources/public/css/github.css" rel="stylesheet"><link href="https://use.typekit.net/kxb8fhj.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Crimson+Pro" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/clojure.min.js"></script><script>hljs.highlightAll()</script></head><body class="p-8"><div class="flex gap-5 mb-4"><h2 class="font-bold"><a href="/" style="color:#6679CC;border-color:#6679CC;">Home</a></h2></div><div class="my-3"><h1>Abstraction</h1><p>Abstraction is a widely used, but deeply overloaded term. Programming is full of tropes like &quot;program at the right level of abstraction&quot;, &quot;avoid premature abstraction&quot;, and &quot;every abstraction is leaky&quot;. All these imagine a program as a hierarchy of levels, and these levels as abstractions. But what defines these levels, really? You can definitely <i>feel</i> them in your programs, but can you explain what they are?</p><p>We could continue to be imprecise about what we mean by abstraction. Abstraction is a pretty successful idea in the software engineering world, even if most people use it without saying exactly what it means. But I find it hard to talk about abstraction in real-world conversations. We need to share a common language to make progress. Hopefully reading this post can help future discussions on the subject.</p><p>Let's start with the definition from Rich Hickey: &quot;Abstraction is about drawing from a set of exemplars some essential thing.&quot;</p><p>(Fun side note: this definition is recursive. Abstraction is <i>itself</i> an abstraction.)</p><p>I like this definition because it's both correct, precise, and I can explain it to a 5 year old. But it needs unpacking. </p><p>If abstraction is drawing from a set of exemplars, let's look at an example Rich Hickey created himself: the collection abstraction in Clojure. </p><p>A collection supports three operations:</p><ul><li><code>count</code> - for getting the number of items in the collection</li><li><code>conj</code> - for 'adding' to the collection</li><li><code>seq</code> - to get a sequence that can walk the entire collection.</li></ul><p>The operations maintain these invariants:</p><ul><li>the sequence of items in the collection contains all the items that have been added to the collection</li><li>the size of the collection is equal to number of items that have been added to the collection</li></ul><p>These properties adhere to Rich's definition of an abstraction. If something has implementations for these operations, and the operations satisfy these invariants, that thing is a collection.</p><p>This idea of a collection is an abstract one because it leaves out details of how it works. There is not enough information in the definition to create a working collection. There is only enough information to say what a collection <i>is</i>. The collection abstraction does not specify anything about how its invariants are maintained, how its operations are implemented, or even how to create one. That is the job of the abstraction's concretions. </p><p>A value is said to be a concretion of an abstraction if it has all the properties of the abstraction. But it can have other properties too. For example, the collection could be ordered, or not. It could have 0(1) access, or not. But these properties are not considered, in the abstract domain. If all you know about something is that it is a collection, you cannot know any of these things.</p><p>It is sometimes helpful to imagine an abstraction as a function of concrete collections to abstract collections, called an abstraction function. The function is surjective: For every abstract value, there are one or more corresponding concrete values.</p><pre><code class="text">the sequence '(1 2 3)
the vector    [1 2 3]    =&gt;   these all map to the same abstract collection
the set      #{1 2 3}
</code></pre><p>This reveals a fundamental property of abstraction: if an abstraction is about finding common things between values, an abstract value must contain the same or less information than its corresponding concrete values. You always have enough information to get the abstract value from a concrete one, but not the other way around.</p><p>Now that we know what an abstraction is, let's acknowledge some things that are not abstractions.</p><p><strong>Interfaces, protocols or typeclasses</strong></p><p>These enumerate operations on a data type, but they are not abstractions since they omit all other types of information. For example, the IPersistentCollection is the interface for the collection in Clojure, and says that all collections must implement <code>count</code>, <code>conj</code>, and <code>seq</code> operations. But it says nothing about the invariants of these operations.</p><p>An interface/protocol/typeclass is not even necessary to create an abstraction. Consider the abstraction of a point in 2D space. Here are three examples of points in Clojure:</p><pre><code class="clojure">(def my-map-point {:x 10 :y 20})
(def my-vector-point [10 20])
(def my-string-point &quot;Point(10, 20)&quot;)
</code></pre><p>We could unite these instances under one interface and define a set of valid operations on points. That might be good programming practice, but it's unnecessary. In fact, we already know what a point is without writing <i>any</i> code. We can simply imagine it. To prove my point, consider how the above examples map to a specific abstract value, namely the point where x=10 and y=20. We didn't need a protocol, interface, or typeclass to know that.</p><p><strong>Functions</strong></p><p>Functions are black boxes that take inputs, might do something, and return a value. Functions can be used to transform or remove information from a complex value into a simpler representation. This can sometimes looks equivalent to an abstraction, but it isn't the same.</p><p>For example, would you say Java's <code>Integer.parseInt</code> function is an abstraction? Not quite. It converts a value of type <code>String[]</code> to the <code>int</code> type, but it doesn't say anything else. An integer is actually an abstraction where the operations adhere to certain mathematical axioms like addition and substraction. <code>Integer.parseInt</code> just converts between two representations of integers: <code>String[]</code> and <code>int</code>. A value <code>&quot;1010&quot; : String[]</code> represents the same integer as the value <code>10 : int</code>, just as <code>&quot;1010&quot; + &quot;0001&quot; = &quot;1011&quot;</code> represents the same operation as <code>10 + 1 = 11</code>. The conversion between representations of an abstraction is not what defines an abstraction.</p><p><strong>Classes</strong></p><p>Classes combine an interface (the list of the class's methods) with implementations of the interface. If an interface isn't required for an abstraction, a class is even more overkill. All previous arguments apply.</p><p><strong>Types</strong></p><p>A type is a set of values that a compiler can use to constrain the operations made on each of its members. An abstraction is not a type, because there is nothing in its definition that allows the compiler to constrain operations in any way, as a type does. Two examples: the collection abstraction isn't a type, and neither is the point abstraction above. But is every type an abstraction? Well, here is a definition of a tree type in ML:</p><pre><code class="ML">datatype point = Point of (double * double)
</code></pre><p>Here a <code>point</code> is a product type of doubles that is created using the type constructor <code>Point</code>. But by defining it this way we have already made more assumptions than necessary for a point abstraction. </p><p>Here are four things defined above that aren't necessary for a point abstraction:</p><ul><li>Points need to be created with the <code>Point</code> type constructor</li><li>X and Y are doubles</li><li>X and Y can be accessed by pattern matching on a value of type <code>Point</code></li><li>Points can contain no other information other than X and Y. You can't add a 3rd dimension to a point, or an ID, or give the point a name.</li></ul><p>These smell like implementation details. From my perspective, these are the only properties you need to know about a 2D point: </p><ol><li>A point has at least two values, which represent the x and y axes in vector space.</li><li>Operations on points should be defined to adhere to the axioms in mathematics. For example, addition of two points should do pointwise addition.</li></ol><p>In the examples of points in Clojure shown previously, few assumptions were made. The common thread between them all is that they have X and Y points defined (somehow), and you could <i>imagine</i> defining operations on them that match mathematical axioms.</p><p>The important insight to make is that abstraction doesn't need to be written down anywhere to be present. It can exist in documentation, in comments, or only in the mind of the programmer. As long as it can be named and defined, it exists.</p></div></body></html>