<html><head><meta charset="UTF-8"><title>Callum Herries</title><meta content="My personal site." name="description"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="../resources/public/css/app-components.css" rel="stylesheet"><link href="../resources/public/css/app-utilities.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Crimson+Pro" rel="stylesheet"></head><body class="pt-24 p-8 leading-7 text-gray-700"><div class="my-3"><h1>Piping Python</h1><p>Today I was writing some Python code where I needed to pipe data through a sequence of steps. You can do this in R with the pipe operator <code>%&gt;%</code>, and in Clojure with the threading macro <code>-&gt;</code> but Python only has plain old function calls. Luckily I came across <a href="https://github.com/0101/pipetools">pipetools</a>, a library that adds this functionality in Python.</p><p>Piping values through functions is best suited to problems where:</p><ul><li>You calculate a value from a sequence of steps</li><li>You do not need to name intermediate values</li></ul><p>Let's take some code from a respected Python programmer, and try to implement it with pipetools. Here's Peter Norvig's solution to 2018 Advent of Code, Day 11:</p><pre><code>The power level in a given fuel cell can be found through the following process:
</code><ol><code><li>Find the fuel cell's rack ID, which is its X coordinate plus 10.2. Begin with a power level of the rack ID times the Y coordinate.
3. Increase the power level by the value of the grid serial number (your puzzle input).
4. Set the power level to itself multiplied by the rack ID.
5. Keep only the hundreds digit of the power level (so 12345 becomes 3; numbers with no hundreds digit become 0).
6. Subtract 5 from the power level.
</li></code></ol></pre><p>Here is Norvig's Python code:</p><pre><code>def power_level(point):
    rack_id = point[0] + 10
    level = (rack_id * point[1] + serial) * rack_id
    return (level // 100) % 10 - 5
</code></pre><p>And here's my code, written with pipetools:</p><pre><code>def power_level(point):
    rack_id = point[0] + 10 # Find the fuel cell's rack ID, which is its X coordinate plus 10.
    return rack_id &gt; (pipe
        | X * point[1]    # Begin with a power level of the rack ID times the Y coordinate.
        | X + serial      # Increase the power level by the value of the grid serial number (your puzzle input).
        | X * rack_id     # Set the power level to itself multiplied by the rack ID.
        | (X // 100) % 10 # Keep only the hundreds digit of the power level (so 12345 becomes 3; numbers with no hundreds digit become 0).
        | X - 5           # Subtract 5 from the power level.
    )
</code></pre><p>Norig's solution is dense, and it's not so easy to see how the code translates to the instructions. It's also not clear why he created a 'level' variable, only to perform some more operations on it. It would be worse if the problem was 10 times longer. Sure, my piped solution has more lines, but once you understand that it's just a pipeline, it's easier to break down and read. Every step in the written instructions has a corresponding line in the code.</p><p>By the way, this is the Clojure version, with the threading macro:</p><pre><code>(defn power-level [[x y]]
  (let [rack-id (+ x 10)] ; Find the fuel cell's rack ID, which is its X coordinate plus 10.
    (-&gt; rack-id
      (* y)               ; Begin with a power level of the rack ID times the Y coordinate.
      (+ serial)          ; Increase the power level by the value of the grid serial number (your puzzle input).
      (* rack-id)         ; Set the power level to itself multiplied by the rack ID.
      (quot 100)          ; Keep only the hundreds digit of the power level (so 12345 becomes 3; numbers with no hundreds digit become 0).
      (mod 10)
      (- 5))))            ; Subtract 5 from the power level.
</code></pre></div></body></html>